# Memento

객체의 상태를 메멘토라고 불리는 객체에 저장했다가 다시 꺼내서 나중에 객체의 상태를 이전의 상태로 되돌리는 패턴

<br>



### 사전적 정의

> memento
>
> 1. 기념물   2. 유품   3. 추억거리
>
> [*다음 영어사전*](https://alldic.daum.net/search.do?q=memento)



<br>



### 언제 사용하나?

**작업취소** 요청 같이 객체를 이전의 상태로 복구시켜야하는 경우나 특정 시점의 객체의 상태를 알고 싶을 때.



<br>



### 이 패턴이 해결하고자 하는 문제는?

파워포인트의 연결선 실행 취소`undo` 기능을 구현할 때 다음과 같은 어려움이 있다.

- 이전 상태로 되돌리려면 선의 시작점부터 끝점, 길이 등의 모든 상태를 알고 있어야 한다. undo는 되돌리려는 시점의 모든 상태를 알아야하는데 그 시점의 상태를 어떻게 저장할 수 있을까? 

- `undo`를 한번만 실행한다면 직전의 상태만 알면 된다. 그런데 `undo`를 여러번 실행한다면 어떨까? 아홉번 열번 실행한다면 아홉번 열번의 상태를 다 알아야만 한다. 이처럼  `undo` 를 한 번이 아닌 여러번 실행하면 이전의 상태들을 어떻게 저장할 것인가?

  

>  *디자인 문제*

- **캡슐화를 위반하지 않으면서 나중에 객체를 이 상태로 복원 할 수 있도록 객체의 내부 상태를 어떻게 캡처하고 외부에서 표현할 수 있을까?** 



<br>



### 핵심 아이디어

이 패턴의 핵심 아이디어는 객체`originator` 자체가 내부 상태 `to/from a memento`를 **저장/복원**하도록하는 것이다. `Memento`를 만든 `originator` 만이 `Memento`에 액세스 할 수 있다.  

>  *Only the originator that created a memento is permitted to access it.*



- ***저장하고자 하는 상태를 핵심 객체로부터 분리시켜*** 시스템에서 핵심적인 기능을 담당하는 객체의 중요한 생태를 저장
- originator 객체의 **캡슐화 유지**👍🏻
  - 캡슐화란 객체 외부에서 액세스 할 수 없도록 객체의 표현 `필드, 배열, 컬렉션 등과 같은 데이터 구조` 및 객체 내부의 구현을 숨기는 것을 의미한다
  - 객체의 내부 상태는 모든 내부 데이터 구조와 해당 값을 말한다.



<br> 

### 어떻게 해결하나?

- `Originator` 및 `Memento` 객체를 정의

  - Originator는 내부 상태를 Memento 에 저장하고 Memento에서 이전 상태로 복원하기 위한 작업을 정의한다. 

    ```java
    createMemento () : return new Memento (state)
    restore(memento): state = memento.getState()
    ```

  - Memento는 originator의 내부 상태를 저장하는 데 필요한 데이터 구조를 정의하여, originator가 아닌 다른 객체에 의한 액세스로부터 보호된다. 

    - Memento를 originator의 내부 클래스로 구현하고 모든 Memento 멤버를 private 선언한다.

    > 스냅샷을 찍으려면 originator 객체의 모든 상태에 접근할 수 있어야한다. originator의 모든 상태의 getter들이 다 노출이 된다면 다른 곳에서도 가져다 쓸 수 있기 때문에 캡슐화가 깨진다. 이 getter에 originator만 접근할 수 있다는 건 다른 객체들은 그 상태에 접근하지 못하기 때문에 캡슐화가 유지될 수 있고, 전체 상태가 외부로는 노출되지 않는다

    

    <br>

    

- originator의 내부 상태 저장 / 복원의 책임을 가지고 있는 `caretaker`는 list of mementos을 보유하여 memento를 원래 상태로 되돌려 이전 상태로 복원 할 수 있다.

  **caretaker은 메멘토에 접근 할 수 없다.** 메멘토를 만든 originator만 액세스 할 수 있다. 이를 통해 캡슐화를 위반하지 않으면서 originator 내부 상태를 저장하고 복원할 수 있다.



![memento pattern sequence diagramì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://upload.wikimedia.org/wikipedia/commons/3/38/Memento_design_pattern_sequence1.png)



- 점증적 상태 변경 저장 : 변경된 부분만 저장 `ex) git`
  - 과거 특정 어느 시점의 값을 보고 싶을 때도 메멘토가 유용하다. 스냅샷간의 차이만큼 더해주고 빼면 어느 특정 시점의 스냅샷을 불러와서 보여줄 수 있음
  - 변경 부분만 저장하면 비용을 극단적으로 줄일 수 있다. 변경부분만 저장하다가 특정 시점으로 돌아가려고 하면 이 변경된 부분만 역으로 변경하면 된다. 더한 기록은 빼고 뺐던 기록은 더해주고 마지막 상태만 알고 있으면 쭉쭉 돌아가고 싶은 스냅샷 부분이 나온다. 전체를 기억하지 않더라도. 

<br> 

### 장점

- 상태관리의 책임을 메멘토에 넘기기 때문에 originator는 히스토리를 기억할 필요가 없다. originator의 클래스는 단순해진다
- originator 객체의 캡슐화
  - 내부 데이터 구조에 액세스하지 않고(캡슐화를 위반하지 않으면서)  객체의 내부 상태를 다른 객체`외부 `에 저장할 수 있다.
- 복구 기능을 구현하기 쉽다



<br>



### 단점

- 상태를 저장하고 복구하는 데 시간이 오래 걸릴 수 있다

- 런타임 비용이 발생
  – 많은 양의 데이터로 많은 수의 메멘토를 사용하면 메모리 및 시스템 성능에 영향을 줄 수 있다.

  > *"Unless encapsulating and restoring Originator state is cheap, the pattern might not be appropriate."*
  >
  > Originator 클래스의 상태를 보호하는 비용과 상태 복구의 비용이 싸지 않으면, 메멘토 패턴은 적합하지 않습니다.
  >
  >  *[GoF, p375]* 



<br>



### 캡슐화에 대하여 !!!!

> - 어떤 객체에 getter가 정말 필요한 프로퍼티인가? 
>   - getter가 있다면 그 객체는 외부로 노출된다. 결국 getter를 통해 얻은 정보를 누군가 사용한다는 것을 의미한다. 
>   - 어떤 프로퍼티는 그 객체에서 필요한 정보인데 다른 곳에서 가져다 쓴다면 정보가 변경했을 때 문제가 발생한다. getter를 통해 이 정보를 가져다 쓴 곳도 의도하지 않았더라도 다 바뀌게 된다.
>   - immutable이 아닌 컬렉션을 그대로 반환하면 더 큰 문제가 생길 수 있다. 외부에서 값을 변경이 가능해지고, 외부에서 변경한 값이 원본 객체에 영향을 미치면 생각치도 못하게 객체의 상태가 변하게 된다. (+ 그래서 코틀린은 기본적으로 다 불변) 그렇기 때문에 컬렉션을 반환할 때는 한번 더 고민해보아야 한다. 정말 컬렉션을 반환해야 하는 것인가? 복사본을 반환해도 되나?
>   - 객체가 노출하는 정보를 줄인다는 건 의존도가 떨어진다는 걸 의미한다. 노출할 필요가 없는 정보는 최대한 공개를 하지 말자. 



<br> 

### 더 찾아볼 것

- java에서의 직렬화
- `메멘토 객체가 수동적입니다`에서 수동적이라는 말의 의미 



<br>



### 느낀점

- 캡슐화에 대해 한번 더 고민해볼 수 있는 시간이었음
- 왜라고 앞으로 더 많이 고민해보고 싶다



