# 배경지식

#### IDE (통합 개발 환경)

코딩, 디버그, 컴파일, 배포 등 프로그램 개발에 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을 제공하는 소프트웨어이다.



# git

소스코드를 완성하면서 `의미있는 지점` 마다 기억할 필요가 있다. git을 활용하면 원하는 시점에서의 변경사항을 기록하게 할 수 있다.

#### 필수 명령어

- add
- commit
- branch
- checkout
- merge



#### 의미있는 지점이란?

* `commit`은 `git이 관리해주는 history의 대상` 이 된다. 유의미한 최소단위로.. 
* 시스템 전체를 완성해서 하나의 `commit`으로 만들어서도, 그렇다고 하나의 클래스나 메소드가 추가될 때마다 무의미하게 일일이 `commit`으로 만들어서도 안된다는 얘기다.
* 가계부 프로그램을 만든다고 해보자. 가계부에는 `수입`과 `지출`, `일별/주별/월별/연도별/분류별 합계`, `통계 `등 기능들을 구현한다고 하자. 그 중에서 `지출` 기능을 구현할 때,
    * **지출이라는 클래스**가 있고, 그 안에 금액, 지출 분류(식사, 경조사···) 등의 **멤버 변수**가 있고,
    * 지출 인스턴스를 초기화 해주는 **생성자**
    * 각 지출이 있을 때마다 **지출을 (분류,일별,월별,..) 더해주는 메서드** 
    * 지출을 수정할 때 **지출을 수정하는 메서드**
    * 지출을 삭제할 때 **지출을 삭제하는 메서드**
    * 이렇게 하나의 클래스나 메소드가 추가될 때마다 일일이 커밋을 만들기 보다
      * 오 지출 클래스 만듬 ㅋ 커밋
      * 오 지출 클래스 생성자 만듬 ㅋ 커밋
      * 오 지출 클래스의 지출 합계 메서드 만듬 ㅋ 커밋
      * 오 지출 클래스 수정 메서드 만듬 ㅋ 커밋
        이 아니라, 
    * 기본적인 지출 기능을 만들고 *작동할 때*  `commit` 





#### 모든 commit 은 빌드 및 동작 가능한 상태를 유지해야 한다.

충돌이 발생해서 이전 지점으로 돌렸는데, 컴파일 및 빌드가 안된다면 의미가 없다.





#### fork에서 시작해서 PR을 보낼때까지의 흐름

1. 내가 작업하려는 organizations의 공동 작업 레파지토리를 내 레파지토리 `fork`한다
2. 내 컴퓨터에서 원하는 경로에 `git clone`을 한다 (말 그대로 복제한다)
3. 작업한다
4. `git add `
5. `git commit -m "이번 확정본에 대한 설명" `
6. 3-5번을 **반복**한다
7. `git push origin 내 브랜치 `
8. 수정사항이 생기면 다시 3으로 돌아가 반복한다
9. 이제 제출할 것이다 깃헙에서 `pull request` 를 보낸다 





#### git add와 git commit을 할 때 git 내부에서는 어떤 일이?

로컬 저장소에는 `git`이 관리하는 **세그루의 나무**로 구성돼있다. 

첫번째 나무인 **작업 디렉토리** `Working directory` 는 실제 파일들로 이루어져있고,

두번 째 나무인 **인덱스** `Index`는 준비 영역의 역할을 하며,

마지막 나무인 **헤드** `HEAD` 는 최종 확정본`commit`을 나타낸다 



```bash
$ git add <파일 이름>
$ git add *
```

변경된 파일은 위의 명령어로 *인덱스에 추가*된다.

```bash
$ git commit -m "이번 확정본에 대한 설명"
```

실제로 변경 내용을 *확정*하려면 위의 명령을 내려야하고, *변경된 파일이 head에 반영*된다.

하지만 원격 저장소에는 반영이 되지 않는다.

```bash
$ git push origin branch
```

변경 내용을 원격 서버로 올린다. 만약 기존에 있던 원격 저장소를 clone 한게 아니라면, 원격 서버의 주소를 git에게 알려줘야 한다.

```bash
$ git remote add origin <원격 서버 주소>
```





#### git-flow

master, develop, feature, release, hotfix 다섯가지 브랜치 사용을 git에서 제안한다.

* **master**  

  충분히 검증되고 배포된 상용 소스를 버전별로 관리하는 브랜치이다. 즉, 버전 단위로 관리되는 안정화된 브랜치

* **develop**

  실제 개발이 이루어지는 브랜치이다. 

* feature

  새로운 기능을 개발하기 위한 브랜치이다.

  개발 완료 후 develop으로 머지된다.

* release

  기능 개발 완료후 안정화(QA)를 위한 브랜치이다. 

  다음 버전에 포함될 기능이 모두 머지된 시점의 develop브랜치에서 분기하여 안정화 작업이 끝나면 develop과 master 브랜치에 각각 머지된다.

* hotfix

  이미 릴리즈 된 소스에서 버그가 발견되어 긴급히 수정하여 배포할 때 사용하는 브랜치이다.

  master 브랜치에서 분기되어 master브랜치와 develop 브랜치에 머지된다.



#### git clone과 로컬 branch 개발

여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능이 바로 `branch` 다.

> 소프트웨어를 개발할 때에 개발자들은 동일한 소스코드를 함께 공유하고 다루게 됩니다. 동일한 소스코드 위에서 어떤 개발자는 버그를 수정하기도 하고 또 다른 개발자는 새로운 기능을 만들어 내기도 하죠. 이와 같이 여러 사람이 동일한 소스코드를 기반으로 서로 다른 작업을 할 때에는 각각 서로 다른 버전의 코드가 만들어 질 수 밖에 없습니다.
>
>  브랜치란 독립적으로 어떤 작업을 진행하기 위한 개념입니다. 필요에 의해 만들어지는 각각의 브랜치는 다른 브랜치의 영향을 받지 않기 때문에, 여러 작업을 동시에 진행할 수 있습니다.
>

```shell
//브랜치 생성
$ git branch branchname
$ git branch ss21 

// 목록보기
$ git branch 

//브랜치 전환
$git checkout 브랜치이름
```







# 참고

[Git, 가장 쉽게 사용하기 - (2) commit, branch 전략 잘 짜는 법](http://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=220763012361&redirect=Dlog)

[git - 간편 안내서](https://rogerdudler.github.io/git-guide/index.ko.html)

[누구나 쉽게 이해할 수 있는 Git 입문](https://backlog.com/git-tutorial/kr/)

