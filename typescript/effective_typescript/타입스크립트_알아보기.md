## 타입스크립트와 자바스크립트 관계 이해하기

---
타입스크립트는 자바스크립트의 상위집합이다. 다시 말하자면, `.js`내의 코드는 이미 타입스크립트라 할 수 있지만, `.ts` 내의 모든 코드는 자바스크립트가 아니다. 
이는 타입스크립트가 타입을 명시하는 추가적인 문법이 있기 때문이다. 

이러한 특성은 기존에 존재하는 자바스크립트 코드를 그대로 유지하면서 일부분에만 타입스크립트를 적용할 수 있기 때문에, 자바스크립트를 타입스크립트로 마이그레이션 하는 데 도움이 된다. 

```ts
const a = null + 7;
const b = [] + 12;
alert('Hello', 'Typescript');
```
타입스크립트가 자바스크립트의 상위집합이라는 말은 곧 정상 동작하는 자바스크립트는 타입스크립트에서도 문제가 없을 거라 기대할 수 있다. 하지만 위의 코드는 자바스크립트에서 정상 동작하지만, Type checker는 에러를 나타낸다. 

타입스크립트는 기본적으로 자바스크립트의 런타임 동작을 모델링하지만, 의도치 않은 이상한 코드가 오류로 이어질 수 있기 때문에 프로그램에 에러가 발생하지 않더라도, Type checker가 에러를 표시한다.

---

타입 시스템의 목표 중 하나는 런타임에 발생시킬 코드를 미리 찾아내는 것이다. 
타입 구문을 통해 코드의 의도를 명시하여, 코드의 동작과 의도가 다른 부분을 찾을 수 있다. 
명시적인 선언이 없으면 오류의 원인이 정확하지 않을 수 있다.

```ts
const names = ['Alice', 'Bob'];
console.log(names[2].toUpperCase());
```

작성된 프로그램이 타입 체크를 통과하더라도 여전히 런타임에 오류가 발생할 수 있다. 타입스크립트가 이해하는 값의 타입과 실제 값의 차이가 있을 수 있기 때문에 타입 시스템은 정적 타입의 정확성을 보장해주지 않는다. 

## 타입스크립트 설정 이해하기
- noImplicitAny: 모든 변수에 타입을 명시
- strictNullChecks: null과 undefined가 모든 타입에서 허용되는지
    - 이 옵션이 없으면 undefined는 객체가 아닙니다 라는 끔찍한 런타임 오류를 만나게 될 수 있다. 

## 코드생성과 타입이 관계없음을 이해하기
- 타입스크립트 컴파일러는 두 가지 역할을 수행한다
  - 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일
  - 코드의 타입 오류를 체크함

    → 이 두가지는 독립적으로 일어남 
- 타입 오류가 있는 코드도 컴파일 가능하다
- 런타임에는 타입 체크가 불가능하다
- **타입 연산은 런타임에 영향을 주지 않는다**
- 런타임 타입은 선언된 타입과 다를 수 있다
- 타입스크립트 타입으로는 함수를 오버로드할 수 없다
- 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다

## 구조적 타이핑에 익숙해지기
- 자바스크립트는 본질적으로 덕 타이핑 기반이다. 요구사항을 만족한다면 타입이 무엇인지 신경쓰지 않는다
- 타입스크립트의 타입 시스템은 자바스크립트의 런타임 동작을 모델링한다
- 정확한 타입으로 객체를 순회하는 것은 까다로운 문제다. 루프보다는 모든 속성을 각각 더하는 구현이 더 낫다
