## 타입스크립트와 자바스크립트 관계 이해하기

---
타입스크립트는 자바스크립트의 상위집합이다. 다시 말하자면, `.js`내의 코드는 이미 타입스크립트라 할 수 있지만, `.ts` 내의 모든 코드는 자바스크립트가 아니다. 
이는 타입스크립트가 타입을 명시하는 추가적인 문법이 있기 때문이다. 

이러한 특성은 기존에 존재하는 자바스크립트 코드를 그대로 유지하면서 일부분에만 타입스크립트를 적용할 수 있기 때문에, 자바스크립트를 타입스크립트로 마이그레이션 하는 데 도움이 된다. 

```ts
const a = null + 7;
const b = [] + 12;
alert('Hello', 'Typescript');
```
타입스크립트가 자바스크립트의 상위집합이라는 말은 곧 정상 동작하는 자바스크립트는 타입스크립트에서도 문제가 없을 거라 기대할 수 있다. 하지만 위의 코드는 자바스크립트에서 정상 동작하지만, Type checker는 에러를 나타낸다. 

타입스크립트는 기본적으로 자바스크립트의 런타임 동작을 모델링하지만, 의도치 않은 이상한 코드가 오류로 이어질 수 있기 때문에 프로그램에 에러가 발생하지 않더라도, Type checker가 에러를 표시한다.

---

타입 시스템의 목표 중 하나는 런타임에 발생시킬 코드를 미리 찾아내는 것이다. 
타입 구문을 통해 코드의 의도를 명시하여, 코드의 동작과 의도가 다른 부분을 찾을 수 있다. 
명시적인 선언이 없으면 오류의 원인이 정확하지 않을 수 있다.

```ts
const names = ['Alice', 'Bob'];
console.log(names[2].toUpperCase());
```

작성된 프로그램이 타입 체크를 통과하더라도 여전히 런타임에 오류가 발생할 수 있다. 타입스크립트가 이해하는 값의 타입과 실제 값의 차이가 있을 수 있기 때문에 타입 시스템은 정적 타입의 정확성을 보장해주지 않는다. 

## 타입스크립트 설정 이해하기
- noImplicitAny: 모든 변수에 타입을 명시
- strictNullChecks: null과 undefined가 모든 타입에서 허용되는지
    - 이 옵션이 없으면 undefined는 객체가 아닙니다 라는 끔찍한 런타임 오류를 만나게 될 수 있다. 

## 코드생성과 타입이 관계없음을 이해하기
### 타입스크립트 컴파일러는 두 가지 역할을 수행한다
> - 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일
> - 코드의 타입 오류를 체크함

→ 이 두가지는 독립적으로 일어남 
### 타입 오류가 있는 코드도 컴파일 가능하다
만약 오류가 있을 때 컴파일하지 않으려면, `tsconfig.json` 에 `noEmitOnError`를 설정하면 됨
### 런타임에는 타입 체크가 불가능하다

> 런타임에 타입을 유지하는 방법
1. [in 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/in)를 통해 속성이 존재하는지 체크 
   
   in 연산자를 사용해서 RN에서 오류난 적이 있다. 벌써 몇개월이 지나 무슨 에러였는지 가물가물하다. 지금 센트리 들어가니까, 날라가고 없네. 정리해둘걸 
2. 태그 기법
   런타임에 접근 타입 정보를 명시적으로 기입 
3. 타입을 클래스로 만들기 
    런타임에 접근 불가한 타입과 런타임에 접근 가능한 값을 둘 다 사용가능함. 인터페이스는 타입으로만 사용 가능하지만, 클래스로 선언하면 타입과 값 모두 사용할 수 있다. 
    ```ts
    type Shape = Square | Rectangle   //타입으로 참조
    shape instanceof Rectangle    //값으로 참조
    ```

### **타입 연산은 런타임에 영향을 주지 않는다**

```ts
function asNumber(val: number | string): number {
  return val as number
}

/* 위의 함수는 타입 체크는 통과하지만 다음과 같이 트랜스파일됨. 코드에 아무 정제 과정이 없음 */
function asNumber(val) {
  return val;
}

/* 의도한 동작 */
function asNumber(val: number | string): number {
  return typeof val === 'string' ? Number(val) : val;
}


```

### 런타임 타입은 선언된 타입과 다를 수 있다
타입은 런타임에 제거된다. 타입스크립트에서 런타임 타입과 선언된 타입이 맞지 않을 수 있다. 

### 타입스크립트 타입으로는 함수를 오버로드할 수 없다

### 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다
- 타입과 타입 연산자는 자바스크립트로 변환할 때 제거되기 때문에 런타임 성능에 영향을 주지 않는다
- 대신 빌드타임 오버헤드가 있음

## 구조적 타이핑에 익숙해지기
- 자바스크립트는 본질적으로 덕 타이핑 기반이다. 요구사항을 만족한다면 타입이 무엇인지 신경쓰지 않는다
- 타입스크립트의 타입 시스템은 자바스크립트의 런타임 동작을 모델링한다
- 정확한 타입으로 객체를 순회하는 것은 까다로운 문제다. 루프보다는 모든 속성을 각각 더하는 구현이 더 낫다
